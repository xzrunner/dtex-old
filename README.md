# DTex

通过贴图做缓存，减少drawcall次数。通过更新缓存，减少内存使用。通过缓存sprite或屏幕，减少cpu开销。

## LOD

支持加载不同缩放的原始资源。在这里使用的目的是减少缓存没命中时的等待时间。根据机器性能或摄像机的位置来调整实际用哪层来显示，为了尽量减少drawcall次数以及fragment的传输量。

比如可以用三层：原始尺寸的高精度图，50% × 50%的中精度图，25% × 25%的低精度图。

结合通过异步加载可以：1，进场景前加载低精度图，减少等待时间。进场景后再加载高精图。2，当要绘制缓存中没有的贴图时，先加载低精图，这样能很快显示出来。另一个线程加载高精图，加载完成后替换之前的低精图。

## 不同层次的缓存

### C4
内存中合并后再提交到显存。创建出来后便不再更新，因为使用pvr和etc1格式的压缩贴图，更新代价比较大。一般是在loading游戏时使用。

用途：在游戏loading时，把包内压缩贴图格式的众多小图合成一张或多张大图。比如可以合并UI和特效这种在不同场景都会使用到，又不会变化的资源。或者合并能用到的所有低精资源，结合C2使用。压缩纹理还有一个优势是Random Access，可以按4*4小块的粒度来热更资源。

注意：计算压缩贴图的过程太慢了，直接拼接现成的倒可以很快。所以合图时不能缩放，只能选择LOD不同的预先做好的资源。

### C3
通过直接绘制到贴图上的方式(FBO)来创建和更新。不使用压缩贴图，可以更新。缓存的key是资源包，就是预先合并过的大些的贴图。一般是在loading游戏或者loading场景时使用。

用途：可以动态根据机器内存，最大贴图尺寸和屏幕分辨率来调整合图参数。资源包的数量可以更多，贴图尺寸可以更小，方便热更新。

### C2
通过直接绘制到贴图上的方式(FBO)来创建和更新。不使用压缩贴图，可以更新。缓存的key是每张小图片。一般是在游戏中使用。

用途：比如游戏中根据剧情要依次出现N个角色，就可以依次加载进来，替换掉之前的不用的部分，没必要在进场景前一次加载所有要用到的资源。

替换策略：1，多张贴图时：按顺序依次插入，插满时清空最老的那张。2，单张贴图时：分成四个区域，插满时清空最老的那块。

### C1
通过直接绘制到贴图上的方式(FBO)来创建和更新。不使用压缩贴图，可以更新。缓存的key是sprite，一般是重复的角色或粒子发射器。

用途：N个角色在做同样的动作，就可以每帧只画一个到缓存中，再直接画N个矩形到游戏中。也可以用于缓存看不出差别的N个同一个粒子发射器。

### CS
缓存屏幕，只更新变化的部分。

用途：没有变化的界面不用每帧重复刷新，比如打开的UI界面。进行平移和缩放操作，每帧的变化部分也是很少的。

### CG
缓存文字图元数据，结合在C2里使用，为了填充的更满一些。缓存的key是图元的unicode编码。

### 关系
从上倒下依次：1，贴图更新的越来越频繁。2，贴图尺寸越来越小。

可以独立使用，也可以合在一起用。C3和C2合在一起就可以解决缓存没命中的问题，也是很省内存的策略：C3加载的scale很小，可以把会用到的贴图全都加载进来，C2只加载当前要用到的，scale可以大一些。当出现缓存没命中时，先直接使用C3的，这时效果不是最好但能显示出来不用等待，异步加载分辨率更高的到C2，完成后替换成使用C2的。



